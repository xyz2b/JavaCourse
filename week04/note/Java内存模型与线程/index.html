<!DOCTYPE html>
<html>
	<head>
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<meta charset="utf-8" />
		<link rel="stylesheet" type="text/css" href="css/style.css" />
		<title>Java内存模型与线程</title>
	</head>
<body>
<h1>Java内存模型与线程</h1>

<h2>Java内存模型</h2>

<h3>主内存与工作内存</h3>

<p>Java内存模型规定了所有的变量都存储在主内存(Main Memory)中。每条线程还有自己的工作内存(Working Memory)，线程的工作内存中保存了被该线程使用的变量的主内存副本，线程对变量的所有操作(读取、赋值等)都必须在工作内存中进行，而不能直接读写主内存中的数据。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成</p>

<p>线程、主内存、工作内存三者交互关系如下图所示</p>

<figure><img src="DraggedImage.png"/></figure>

<h3>内存间交互操作</h3>

<p>关于主内存与工作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存、如何从 工作内存同步回主内存这一类的实现细节，Java内存模型中定义了以下8种操作来完成。Java虚拟机实 现时必须保证下面提及的每一种操作都是原子的、不可再分的。</p>

<ul>
	<li>lock（锁定）：作用于主内存的变量，它把一个变量标识为一条线程独占的状态</li>
	<li>unlock（解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定</li>
	<li>read（读取）：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用</li>
	<li>load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中</li>
	<li>use（使用）：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作</li>
	<li>assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作</li>
	<li>store（存储）：作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用</li>
	<li>write（写入）：作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中</li>
</ul>

<p>如果要把一个变量从主内存拷贝到工作内存，那就要按顺序执行read和load操作，如果要把变量从工作内存同步回主内存，就要按顺序执行store和write操作。注意，Java内存模型只要求上述两个操作必须按顺序执行，但不要求是连续执行。也就是说read与load之间、store与write之间是可插入其他指令的，如对主内存中的变量a、b进行访问时，一种可能出现的顺序是read a、read b、load b、load a。</p>

<p>Java内存模型还规定了在执行上述8种基本操作时必须满足如下规则：</p>

<ul>
	<li>不允许read和load、store和write操作之一单独出现，即不允许一个变量从主内存读取了但工作内存不接受，或者工作内存发起回写了但主内存不接受的情况出现</li>
	<li>不允许一个线程丢弃它最近的assign操作，即变量在工作内存中改变了之后必须把该变化同步回主内存</li>
	<li>不允许一个线程无原因地（没有发生过任何assign操作）把数据从线程的工作内存同步回主内存中</li>
	<li>一个新的变量只能在主内存中“诞生”，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量，换句话说就是对一个变量实施use、store操作之前，必须先执行assign和load操作</li>
	<li>一个变量在同一个时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁</li>
	<li>如果对一个变量执行lock操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign操作以初始化变量的值</li>
	<li>如果一个变量事先没有被lock操作锁定，那就不允许对它执行unlock操作，也不允许去unlock一个被其他线程锁定的变量</li>
	<li>对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store、write操作）</li>
</ul>

<h3>原子性、可见性与有序性</h3>

<p>1.原子性(Atomicity)</p>

<p>由Java内存模型来直接保证的原子性变量操作包括read、load、assign、use、store和write这六个， 我们大致可以认为，基本数据类型的访问、读写都是具备原子性的</p>

<p>如果应用场景需要一个更大范围的原子性保证（经常会遇到），Java内存模型还提供了lock和 unlock操作来满足这种需求，尽管虚拟机未把lock和unlock操作直接开放给用户使用，但是却提供了更 高层次的字节码指令monitorenter和monitorexit来隐式地使用这两个操作。这两个字节码指令反映到Java 代码中就是同步块——synchronized关键字，因此在synchronized块之间的操作也具备原子性</p>

<p>2.可见性(Visibility)</p>

<p>可见性就是指当一个线程修改了共享变量的值时，其他线程能够立即得知这个修改。上文在讲解 volatile变量的时候我们已详细讨论过这一点。Java内存模型是通过在变量修改后将新值同步回主内 存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式来实现可见性的，无论是 普通变量还是volatile变量都是如此。普通变量与volatile变量的区别是，volatile的特殊规则保证了新值 能立即同步到主内存，以及每次使用前立即从主内存刷新。因此我们可以说volatile保证了多线程操作 时变量的可见性，而普通变量则不能保证这一点</p>

<p>除了volatile之外，Java还有两个关键字能实现可见性，它们是synchronized和final。同步块的可见 性是由“对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store、write操 作）”这条规则获得的。而final关键字的可见性是指：被final修饰的字段在构造器中一旦被初始化完 成，并且构造器没有把“this”的引用传递出去（this引用逃逸是一件很危险的事情，其他线程有可能通 过这个引用访问到“初始化了一半”的对象），那么在其他线程中就能看见final字段的值</p>

<p>3.有序性(Ordering)</p>

<p>Java程序中天然的有序性可以 总结为一句话：如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另一个线程， 所有的操作都是无序的。前半句是指“线程内似表现为串行的语义”（Within-Thread As-If-Serial Semantics），后半句是指“指令重排序”现象和“工作内存与主内存同步延迟”现象</p>

<p>Java语言提供了volatile和synchronized两个关键字来保证线程之间操作的有序性，volatile关键字本身就包含了禁止指令重排序的语义，而synchronized则是由“一个变量在同一个时刻只允许一条线程对 其进行lock操作”这条规则获得的，这个规则决定了持有同一个锁的两个同步块只能串行地进入</p>

<h3>先行发生原则</h3>

<p>下面是Java内存模型下一些“天然的”先行发生关系，这些先行发生关系无须任何同步器协助就已 经存在，可以在编码中直接使用。如果两个操作之间的关系不在此列，并且无法从下列规则推导出 来，则它们就没有顺序性保障，虚拟机可以对它们随意地进行重排序</p>

<ul>
	<li>程序次序规则（Program Order Rule）：在一个线程内，按照控制流顺序，书写在前面的操作先行 发生于书写在后面的操作。注意，这里说的是控制流顺序而不是程序代码顺序，因为要考虑分支、循环等结构</li>
	<li>管程锁定规则（Monitor Lock Rule）：一个unlock操作先行发生于后面对同一个锁的lock操作。这里必须强调的是“同一个锁”，而“后面”是指时间上的先后</li>
	<li>volatile变量规则（Volatile Variable Rule）：对一个volatile变量的写操作先行发生于后面对这个变量的读操作，这里的“后面”同样是指时间上的先后</li>
	<li>线程启动规则（Thread Start Rule）：Thread对象的start()方法先行发生于此线程的每一个动作</li>
	<li>线程终止规则（Thread Termination Rule）：线程中的所有操作都先行发生于对此线程的终止检 测，我们可以通过<code>Thread::join()</code>方法是否结束、<code>Thread::isAlive()</code>的返回值等手段检测线程是否已经终止执行</li>
	<li>线程中断规则（Thread Interruption Rule）：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过<code>Thread::interrupted()</code>方法检测到是否有中断发生</li>
	<li>对象终结规则（Finalizer Rule）：一个对象的初始化完成（构造函数执行结束）先行发生于它的 finalize()方法的开始</li>
	<li>传递性（Transitivity）：如果操作A先行发生于操作B，操作B先行发生于操作C，那就可以得出操作A先行发生于操作C的结论</li>
</ul>

<h2>Java线程</h2>

<h3>创建线程</h3>

<p>1.继承Thread类创建线程类</p>

<pre><code>public class FirstThread extends Thread {
    private int i;

    @Override
    public void run() {
        for ( ; i &lt; 100; i++) {
            System.out.println(getName() + &quot; &quot; + i);
        }
    }

    public static void main(String[] args) {
        for (int i = 0; i &lt; 100; i++) {
            System.out.println(Thread.currentThread().getName() + &quot; &quot; + i);
            if (i == 20) {
                new FirstThread().start();
                new FirstThread().start();
            }
        }
    }
}</code></pre>

<p>2.实现Runable接口创建线程类(可使用Lambda表达式)</p>

<pre><code>public class SecondThread implements Runnable {
    private int i;

    @Override
    public void run() {
        for ( ; i &lt; 100; i++) {
            System.out.println(Thread.currentThread().getName() + &quot; &quot; + i);
        }
    }

    public static void main(String[] args) {
        for (int i = 0; i &lt; 100; i++) {
            System.out.println(Thread.currentThread().getName() + &quot; &quot; + i);
            if (i == 20) {
                SecondThread st = new SecondThread();
                new Thread(st, &quot;新线程1&quot;).start();
                new Thread(st, &quot;新线程2&quot;).start();
            }
        }
    }
}</code></pre>

<pre><code>public class SecondThread {

    public static void main(String[] args) throws InterruptedException {
        Runnable task = new Runnable() {
            @Override
            public void run() {
                System.out.println(Thread.currentThread().getName());
            }
        };

        new Thread(task, &quot;新线程1&quot;).start();
        new Thread(task, &quot;新线程2&quot;).start();

        System.out.println(Thread.currentThread().getName());
        Thread.sleep(100);
    }
}</code></pre>

<pre><code>public class SecondThread {

    public static void main(String[] args) throws InterruptedException {
        Runnable task = () -&gt; {
                System.out.println(Thread.currentThread().getName());
        };

        new Thread(task, &quot;新线程1&quot;).start();
        new Thread(task, &quot;新线程2&quot;).start();

        System.out.println(Thread.currentThread().getName());
        Thread.sleep(100);
    }
}</code></pre>

<p>3.使用Callable和Future创建线程</p>

<pre><code>public class FutureTaskThread {
    public static void main(String[] args) {
        FutureTask&lt;Integer&gt; task = new FutureTask&lt;&gt;((Callable&lt;Integer&gt;) () -&gt; {
            return sum();
        });

        new Thread(task, &quot;又返回值的线程&quot;).start();

        try {
            System.out.println(&quot;异步计算结果为：&quot; + task.get());
        } catch (Exception ex) {
            ex.printStackTrace();
        }

    }

    private static int sum() {
        return fibo(36);
    }

    private static int fibo(int a) {
        if ( a &lt; 2)
            return 1;
        return fibo(a-1) + fibo(a-2);
    }
}</code></pre>

<h3>状态转换</h3>

<p>Java语言定义了6种线程状态，在任意一个时间点中，一个线程只能有且只有其中的一种状态，并且可以通过特定的方法在不同状态之间转换。这6种状态分别是:</p>

<ul>
	<li>新建（New）：创建后尚未启动的线程处于这种状态。 </li>
	<li>运行（Runnable）：包括操作系统线程状态中的Running和Ready，也就是处于此状态的线程有可 能正在执行，也有可能正在等待着操作系统为它分配执行时间。 </li>
	<li>无限期等待（Waiting）：处于这种状态的线程不会被分配处理器执行时间，它们要等待被其他线 程显式唤醒。以下方法会让线程陷入无限期的等待状态： 

		<ul>
			<li>没有设置Timeout参数的<code>Object::wait()</code>方法；</li>
			<li>没有设置Timeout参数的<code>Thread::join()</code>方法； </li>
			<li><code>LockSupport::park()</code>方法。 </li>
		</ul></li>
	<li>限期等待（Timed Waiting）：处于这种状态的线程也不会被分配处理器执行时间，不过无须等待 被其他线程显式唤醒，在一定时间之后它们会由系统自动唤醒。以下方法会让线程进入限期等待状态：

		<ul>
			<li><code>Thread::sleep()</code>方法； </li>
			<li>设置了Timeout参数的<code>Object::wait()</code>方法； </li>
			<li>设置了Timeout参数的<code>Thread::join()</code>方法； </li>
			<li><code>LockSupport::parkNanos()</code>方法； </li>
			<li><code>LockSupport::parkUntil()</code>方法。 </li>
		</ul></li>
	<li>阻塞（Blocked）：线程被阻塞了，“阻塞状态”与“等待状态”的区别是“阻塞状态”在等待着获取到 一个排它锁，这个事件将在另外一个线程放弃这个锁的时候发生；而“等待状态”则是在等待一段时间，或者唤醒动作的发生。在程序等待进入同步区域的时候，线程将进入这种状态。 </li>
	<li>结束（Terminated）：已终止线程的线程状态，线程已经结束执行。</li>
</ul>

<p>上述6中状态在遇到特定事件发生的时候将会相互转换，如下图所示</p>

<figure><img src="DraggedImage.tiff"/></figure>

</body>
</html>

